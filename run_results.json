{"results": [{"node": {"raw_sql": "select\n    '{{ var(\"object_type\") }}'::varchar as \"object_type\",\n    '{{ var(\"event_type\") }}'::varchar as \"event_type\",    \n    {{ var('object_id_field') }}::varchar as \"object_id\",\n    {{ var('event_timestamp_field') }}::date as \"active_at\"\nfrom {{ var('tablename') }}\nwhere {{ var('object_id_field') }} is not null\n  and {{ var('event_timestamp_field') }} is not null", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "core", "growth_accounting_events"], "unique_id": "model.growth_accounting.growth_accounting_events", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "core/growth_accounting_events.sql", "original_file_path": "models/core/growth_accounting_events.sql", "name": "growth_accounting_events", "resource_type": "model", "alias": "growth_accounting_events", "checksum": {"name": "sha256", "checksum": "5724c7b9c852160a089b2c18958ea92f520eec41b6a17a3695879081c0d3efe6"}, "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [], "sources": [["dummy_data", "growth_accounting_users"]], "depends_on": {"macros": [], "nodes": ["source.growth_accounting.dummy_data.growth_accounting_users"]}, "description": "A view that collects all events relevant for the \"growth accounting\" tables.", "columns": {"object_type": {"name": "object_type", "description": "Common object types include 'user', 'account', and 'visitor'. Objects are the type of person you want to track.", "meta": {}, "data_type": null, "quote": null, "tags": []}, "event_type": {"name": "event_type", "description": "Common event types include 'page view', 'login'. Event types track the repeatable action that the object_type can create.", "meta": {}, "data_type": null, "quote": null, "tags": []}, "object_id": {"name": "object_id", "description": "", "meta": {}, "data_type": null, "quote": null, "tags": [], "descriptoin": "The unique identifier for the object_type - the user_id if it's a user, the account_id if it's an account, etc.\""}, "active_at": {"name": "active_at", "description": "The date at which the event occured. For example, the date the user logged in, or the date the visitor viewed a page.\"", "meta": {}, "data_type": null, "quote": null, "tags": []}}, "meta": {}, "docs": {"show": true}, "patch_path": "models/schema.yml", "build_path": "target/compiled/growth_accounting/models/core/growth_accounting_events.sql", "deferred": false, "compiled_sql": "select\n    'user'::varchar as \"object_type\",\n    'login'::varchar as \"event_type\",    \n    user_id::varchar as \"object_id\",\n    login_at::date as \"active_at\"\nfrom \"dev\".\"raw\".\"growth_accounting_users\"\nwhere user_id is not null\n  and login_at is not null", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "select\n    'user'::varchar as \"object_type\",\n    'login'::varchar as \"event_type\",    \n    user_id::varchar as \"object_id\",\n    login_at::date as \"active_at\"\nfrom \"dev\".\"raw\".\"growth_accounting_users\"\nwhere user_id is not null\n  and login_at is not null"}, "error": null, "status": null, "execution_time": 0.02651834487915039, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.094394Z", "completed_at": "2020-11-10T01:45:31.119945Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.120211Z", "completed_at": "2020-11-10T01:45:31.120225Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{\n    config(materialized='table')\n}}\n\nwith active_days as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at,  -- note this is cast to a 'date' type\n        count(1) as events\n    from {{ ref('growth_accounting_events') }}\n    group by 1,2,3,4\n),\n\nactive_days_enhanced as (\n    select\n        active_days.*,\n        extract('day' from active_at)::integer as active_at_day,\n        extract('month' from active_at)::integer as active_at_month,\n        extract('year' from active_at)::integer as active_at_year,\n        extract('doy' from active_at)::integer as active_at_day_of_year,\n        extract('dow' from active_at)::integer as active_at_day_of_week,\n        extract('quarter' from active_at)::integer as active_at_quarter,\n        extract('week' from active_at)::integer as active_at_week\n    from active_days\n)\n\nselect * \nfrom active_days_enhanced", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "core", "growth_accounting_activity"], "unique_id": "model.growth_accounting.growth_accounting_activity", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "core/growth_accounting_activity.sql", "original_file_path": "models/core/growth_accounting_activity.sql", "name": "growth_accounting_activity", "resource_type": "model", "alias": "growth_accounting_activity", "checksum": {"name": "sha256", "checksum": "68482ec34050c902c64b801cdc45ec749e045b18470eaa21bf62e74f3a2c01c4"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_events"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_events"]}, "description": "A daily aggregate of the activity from the \"growth_accounting_events\" table.", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": "models/schema.yml", "build_path": "target/compiled/growth_accounting/models/core/growth_accounting_activity.sql", "deferred": false, "compiled_sql": "\n\nwith active_days as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at,  -- note this is cast to a 'date' type\n        count(1) as events\n    from \"dev\".\"public\".\"growth_accounting_events\"\n    group by 1,2,3,4\n),\n\nactive_days_enhanced as (\n    select\n        active_days.*,\n        extract('day' from active_at)::integer as active_at_day,\n        extract('month' from active_at)::integer as active_at_month,\n        extract('year' from active_at)::integer as active_at_year,\n        extract('doy' from active_at)::integer as active_at_day_of_year,\n        extract('dow' from active_at)::integer as active_at_day_of_week,\n        extract('quarter' from active_at)::integer as active_at_quarter,\n        extract('week' from active_at)::integer as active_at_week\n    from active_days\n)\n\nselect * \nfrom active_days_enhanced", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith active_days as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at,  -- note this is cast to a 'date' type\n        count(1) as events\n    from \"dev\".\"public\".\"growth_accounting_events\"\n    group by 1,2,3,4\n),\n\nactive_days_enhanced as (\n    select\n        active_days.*,\n        extract('day' from active_at)::integer as active_at_day,\n        extract('month' from active_at)::integer as active_at_month,\n        extract('year' from active_at)::integer as active_at_year,\n        extract('doy' from active_at)::integer as active_at_day_of_year,\n        extract('dow' from active_at)::integer as active_at_day_of_week,\n        extract('quarter' from active_at)::integer as active_at_quarter,\n        extract('week' from active_at)::integer as active_at_week\n    from active_days\n)\n\nselect * \nfrom active_days_enhanced"}, "error": null, "status": null, "execution_time": 0.04932093620300293, "thread_id": "Thread-3", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.121926Z", "completed_at": "2020-11-10T01:45:31.132245Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.160069Z", "completed_at": "2020-11-10T01:45:31.160078Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(**_dbt_schema_test_kwargs) }}", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "event_type", "model": "{{ ref('growth_accounting_events') }}"}}, "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "schema_test", "not_null_growth_accounting_events_event_type"], "unique_id": "test.growth_accounting.not_null_growth_accounting_events_event_type", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "schema_test/not_null_growth_accounting_events_event_type.sql", "original_file_path": "models/schema.yml", "name": "not_null_growth_accounting_events_event_type", "resource_type": "test", "alias": "not_null_growth_accounting_events_event_type", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "severity": "ERROR", "growth_accounting": null}, "tags": ["schema"], "refs": [["growth_accounting_events"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.growth_accounting.growth_accounting_events"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/schema.yml/schema_test/not_null_growth_accounting_events_event_type.sql", "deferred": false, "compiled_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere event_type is null\n\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere event_type is null\n\n\n", "column_name": "event_type"}, "error": null, "status": null, "execution_time": 0.05216550827026367, "thread_id": "Thread-5", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.142975Z", "completed_at": "2020-11-10T01:45:31.171139Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.182054Z", "completed_at": "2020-11-10T01:45:31.182062Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(**_dbt_schema_test_kwargs) }}", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "active_at", "model": "{{ ref('growth_accounting_events') }}"}}, "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "schema_test", "not_null_growth_accounting_events_active_at"], "unique_id": "test.growth_accounting.not_null_growth_accounting_events_active_at", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "schema_test/not_null_growth_accounting_events_active_at.sql", "original_file_path": "models/schema.yml", "name": "not_null_growth_accounting_events_active_at", "resource_type": "test", "alias": "not_null_growth_accounting_events_active_at", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "severity": "ERROR", "growth_accounting": null}, "tags": ["schema"], "refs": [["growth_accounting_events"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.growth_accounting.growth_accounting_events"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/schema.yml/schema_test/not_null_growth_accounting_events_active_at.sql", "deferred": false, "compiled_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere active_at is null\n\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere active_at is null\n\n\n", "column_name": "active_at"}, "error": null, "status": null, "execution_time": 0.05418562889099121, "thread_id": "Thread-4", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.131403Z", "completed_at": "2020-11-10T01:45:31.170488Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.182771Z", "completed_at": "2020-11-10T01:45:31.182779Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(**_dbt_schema_test_kwargs) }}", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "object_id", "model": "{{ ref('growth_accounting_events') }}"}}, "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "schema_test", "not_null_growth_accounting_events_object_id"], "unique_id": "test.growth_accounting.not_null_growth_accounting_events_object_id", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "schema_test/not_null_growth_accounting_events_object_id.sql", "original_file_path": "models/schema.yml", "name": "not_null_growth_accounting_events_object_id", "resource_type": "test", "alias": "not_null_growth_accounting_events_object_id", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "severity": "ERROR", "growth_accounting": null}, "tags": ["schema"], "refs": [["growth_accounting_events"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.growth_accounting.growth_accounting_events"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/schema.yml/schema_test/not_null_growth_accounting_events_object_id.sql", "deferred": false, "compiled_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere object_id is null\n\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere object_id is null\n\n\n", "column_name": "object_id"}, "error": null, "status": null, "execution_time": 0.05618906021118164, "thread_id": "Thread-6", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.132507Z", "completed_at": "2020-11-10T01:45:31.182474Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.186486Z", "completed_at": "2020-11-10T01:45:31.186493Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(severity='ERROR') }}{{ test_not_null(**_dbt_schema_test_kwargs) }}", "test_metadata": {"namespace": null, "name": "not_null", "kwargs": {"column_name": "object_type", "model": "{{ ref('growth_accounting_events') }}"}}, "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "schema_test", "not_null_growth_accounting_events_object_type"], "unique_id": "test.growth_accounting.not_null_growth_accounting_events_object_type", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "schema_test/not_null_growth_accounting_events_object_type.sql", "original_file_path": "models/schema.yml", "name": "not_null_growth_accounting_events_object_type", "resource_type": "test", "alias": "not_null_growth_accounting_events_object_type", "checksum": {"name": "none", "checksum": ""}, "config": {"enabled": true, "materialized": "view", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "severity": "ERROR", "growth_accounting": null}, "tags": ["schema"], "refs": [["growth_accounting_events"]], "sources": [], "depends_on": {"macros": ["macro.dbt.test_not_null"], "nodes": ["model.growth_accounting.growth_accounting_events"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/schema.yml/schema_test/not_null_growth_accounting_events_object_type.sql", "deferred": false, "compiled_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere object_type is null\n\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n    \n    \n\n\n\nselect count(*) as validation_errors\nfrom \"dev\".\"public\".\"growth_accounting_events\"\nwhere object_type is null\n\n\n", "column_name": "object_type"}, "error": null, "status": null, "execution_time": 0.018631458282470703, "thread_id": "Thread-7", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.171479Z", "completed_at": "2020-11-10T01:45:31.184166Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.186778Z", "completed_at": "2020-11-10T01:45:31.186785Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(\n        materialized='table'\n    )\n}}\n\nwith cohorts as (\n    select\n        object_type,\n        event_type,\n        object_id,\n        max(active_at) as last_active_at,\n        min(active_at) as first_active_at,\n        count(1) as num_active_days,\n        count(distinct(active_at_week::varchar || '-' || active_at_year::varchar)) as num_active_weeks,\n        count(distinct(active_at_month::varchar || '-' || active_at_year::varchar)) as num_active_months,\n        count(distinct(active_at_quarter::varchar || '-' || active_at_year::varchar)) as num_active_quarters,\n        count(distinct(active_at_year)) as num_active_years,\n        sum(events) as lifetime_events\n    from {{ ref('growth_accounting_activity') }}\n    group by 1, 2, 3\n)\n\nselect\n    *,\n    extract('day' from first_active_at)::integer as first_active_at_day,\n    extract('month' from first_active_at)::integer as first_active_at_month,\n    extract('year' from first_active_at)::integer as first_active_at_year,\n    extract('doy' from first_active_at)::integer as first_active_at_day_of_year,\n    extract('dow' from first_active_at)::integer as first_active_at_day_of_week,\n    extract('quarter' from first_active_at)::integer as first_active_at_quarter,\n    extract('week' from first_active_at)::integer as first_active_at_week\n    -- last_active_at - first_active_at as lifetime_age_in_days,\n    -- (last_active_at - first_active_at) / 7 as lifetime_age_in_weeks,\n    -- (last_active_at - first_active_at) / 30 as lifetime_age_in_months,\n    -- (last_active_at - first_active_at) / 365 as lifetime_age_in_years\nfrom cohorts", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "core", "growth_accounting_cohorts"], "unique_id": "model.growth_accounting.growth_accounting_cohorts", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "core/growth_accounting_cohorts.sql", "original_file_path": "models/core/growth_accounting_cohorts.sql", "name": "growth_accounting_cohorts", "resource_type": "model", "alias": "growth_accounting_cohorts", "checksum": {"name": "sha256", "checksum": "bce4f5957acc43112eceb6cf04e61a1ad777a54aaf5b85b16968ea9e8b21b1f8"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_activity"]}, "description": "A summary of all object_types and event_types from the \"growth_accounting_events\" view", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": "models/schema.yml", "build_path": "target/compiled/growth_accounting/models/core/growth_accounting_cohorts.sql", "deferred": false, "compiled_sql": "\n\nwith cohorts as (\n    select\n        object_type,\n        event_type,\n        object_id,\n        max(active_at) as last_active_at,\n        min(active_at) as first_active_at,\n        count(1) as num_active_days,\n        count(distinct(active_at_week::varchar || '-' || active_at_year::varchar)) as num_active_weeks,\n        count(distinct(active_at_month::varchar || '-' || active_at_year::varchar)) as num_active_months,\n        count(distinct(active_at_quarter::varchar || '-' || active_at_year::varchar)) as num_active_quarters,\n        count(distinct(active_at_year)) as num_active_years,\n        sum(events) as lifetime_events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1, 2, 3\n)\n\nselect\n    *,\n    extract('day' from first_active_at)::integer as first_active_at_day,\n    extract('month' from first_active_at)::integer as first_active_at_month,\n    extract('year' from first_active_at)::integer as first_active_at_year,\n    extract('doy' from first_active_at)::integer as first_active_at_day_of_year,\n    extract('dow' from first_active_at)::integer as first_active_at_day_of_week,\n    extract('quarter' from first_active_at)::integer as first_active_at_quarter,\n    extract('week' from first_active_at)::integer as first_active_at_week\n    -- last_active_at - first_active_at as lifetime_age_in_days,\n    -- (last_active_at - first_active_at) / 7 as lifetime_age_in_weeks,\n    -- (last_active_at - first_active_at) / 30 as lifetime_age_in_months,\n    -- (last_active_at - first_active_at) / 365 as lifetime_age_in_years\nfrom cohorts", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith cohorts as (\n    select\n        object_type,\n        event_type,\n        object_id,\n        max(active_at) as last_active_at,\n        min(active_at) as first_active_at,\n        count(1) as num_active_days,\n        count(distinct(active_at_week::varchar || '-' || active_at_year::varchar)) as num_active_weeks,\n        count(distinct(active_at_month::varchar || '-' || active_at_year::varchar)) as num_active_months,\n        count(distinct(active_at_quarter::varchar || '-' || active_at_year::varchar)) as num_active_quarters,\n        count(distinct(active_at_year)) as num_active_years,\n        sum(events) as lifetime_events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1, 2, 3\n)\n\nselect\n    *,\n    extract('day' from first_active_at)::integer as first_active_at_day,\n    extract('month' from first_active_at)::integer as first_active_at_month,\n    extract('year' from first_active_at)::integer as first_active_at_year,\n    extract('doy' from first_active_at)::integer as first_active_at_day_of_year,\n    extract('dow' from first_active_at)::integer as first_active_at_day_of_week,\n    extract('quarter' from first_active_at)::integer as first_active_at_quarter,\n    extract('week' from first_active_at)::integer as first_active_at_week\n    -- last_active_at - first_active_at as lifetime_age_in_days,\n    -- (last_active_at - first_active_at) / 7 as lifetime_age_in_weeks,\n    -- (last_active_at - first_active_at) / 30 as lifetime_age_in_months,\n    -- (last_active_at - first_active_at) / 365 as lifetime_age_in_years\nfrom cohorts"}, "error": null, "status": null, "execution_time": 0.05080080032348633, "thread_id": "Thread-2", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.187461Z", "completed_at": "2020-11-10T01:45:31.234061Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.235340Z", "completed_at": "2020-11-10T01:45:31.235348Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{\n    config(materialized='table')\n}}\n\nwith quarterly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_quarter,\n        active_at_year,\n        sum(events) as events\n    from {{ ref('growth_accounting_activity') }}\n    group by 1,2,3,4,5\n),\n    \nquarterly_rollup_enhanced as (\n    select\n        quarterly_rollup.*,\n        4 * (quarterly_rollup.active_at_year - lag(quarterly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc))\n            + \n        quarterly_rollup.active_at_quarter - lag(quarterly_rollup.active_at_quarter) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc)\n            as quarters_since_last_active \n    from quarterly_rollup\n)\n\nselect\n    *,\n    case when quarters_since_last_active is null then true else false end as is_new,\n    case when quarters_since_last_active = 1 then true else false end as is_retained,\n    case when quarters_since_last_active > 1 then true else false end as is_returned\nfrom quarterly_rollup_enhanced", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "accounting", "growth_accounting_by_quarter_draft"], "unique_id": "model.growth_accounting.growth_accounting_by_quarter_draft", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "accounting/growth_accounting_by_quarter_draft.sql", "original_file_path": "models/accounting/growth_accounting_by_quarter_draft.sql", "name": "growth_accounting_by_quarter_draft", "resource_type": "model", "alias": "growth_accounting_by_quarter_draft", "checksum": {"name": "sha256", "checksum": "c0324197b7427536d603e151178062013916a752c3bdd8483415779a753217de"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_activity"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/accounting/growth_accounting_by_quarter_draft.sql", "deferred": false, "compiled_sql": "\n\nwith quarterly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_quarter,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n    \nquarterly_rollup_enhanced as (\n    select\n        quarterly_rollup.*,\n        4 * (quarterly_rollup.active_at_year - lag(quarterly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc))\n            + \n        quarterly_rollup.active_at_quarter - lag(quarterly_rollup.active_at_quarter) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc)\n            as quarters_since_last_active \n    from quarterly_rollup\n)\n\nselect\n    *,\n    case when quarters_since_last_active is null then true else false end as is_new,\n    case when quarters_since_last_active = 1 then true else false end as is_retained,\n    case when quarters_since_last_active > 1 then true else false end as is_returned\nfrom quarterly_rollup_enhanced", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith quarterly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_quarter,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n    \nquarterly_rollup_enhanced as (\n    select\n        quarterly_rollup.*,\n        4 * (quarterly_rollup.active_at_year - lag(quarterly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc))\n            + \n        quarterly_rollup.active_at_quarter - lag(quarterly_rollup.active_at_quarter) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_quarter asc)\n            as quarters_since_last_active \n    from quarterly_rollup\n)\n\nselect\n    *,\n    case when quarters_since_last_active is null then true else false end as is_new,\n    case when quarters_since_last_active = 1 then true else false end as is_retained,\n    case when quarters_since_last_active > 1 then true else false end as is_returned\nfrom quarterly_rollup_enhanced"}, "error": null, "status": null, "execution_time": 0.05118966102600098, "thread_id": "Thread-8", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.187700Z", "completed_at": "2020-11-10T01:45:31.234795Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.236414Z", "completed_at": "2020-11-10T01:45:31.236421Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{\n    config(materialized='table')\n}}\n\nwith weekly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_week,\n        active_at_year,\n        sum(events) as events\n    from {{ ref('growth_accounting_activity') }}\n    group by 1,2,3,4,5\n),\n    \nweekly_rollup_enhanced as (\n    select\n        weekly_rollup.*,\n        52 * (weekly_rollup.active_at_year - lag(weekly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc))\n            + \n        weekly_rollup.active_at_week - lag(weekly_rollup.active_at_week) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc)\n            as weeks_since_last_active \n    from weekly_rollup\n)\n\nselect\n    *,\n    case when weeks_since_last_active is null then true else false end as is_new,\n    case when weeks_since_last_active = 1 then true else false end as is_retained,\n    case when weeks_since_last_active > 1 then true else false end as is_returned\nfrom weekly_rollup_enhanced", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "accounting", "growth_accounting_by_week_draft"], "unique_id": "model.growth_accounting.growth_accounting_by_week_draft", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "accounting/growth_accounting_by_week_draft.sql", "original_file_path": "models/accounting/growth_accounting_by_week_draft.sql", "name": "growth_accounting_by_week_draft", "resource_type": "model", "alias": "growth_accounting_by_week_draft", "checksum": {"name": "sha256", "checksum": "5c9a65f8158e0855024880e0ac9f987d9841f06180051f8045cc6b56e0eb4aa5"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_activity"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/accounting/growth_accounting_by_week_draft.sql", "deferred": false, "compiled_sql": "\n\nwith weekly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_week,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n    \nweekly_rollup_enhanced as (\n    select\n        weekly_rollup.*,\n        52 * (weekly_rollup.active_at_year - lag(weekly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc))\n            + \n        weekly_rollup.active_at_week - lag(weekly_rollup.active_at_week) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc)\n            as weeks_since_last_active \n    from weekly_rollup\n)\n\nselect\n    *,\n    case when weeks_since_last_active is null then true else false end as is_new,\n    case when weeks_since_last_active = 1 then true else false end as is_retained,\n    case when weeks_since_last_active > 1 then true else false end as is_returned\nfrom weekly_rollup_enhanced", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith weekly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_week,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n    \nweekly_rollup_enhanced as (\n    select\n        weekly_rollup.*,\n        52 * (weekly_rollup.active_at_year - lag(weekly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc))\n            + \n        weekly_rollup.active_at_week - lag(weekly_rollup.active_at_week) over (partition by object_type, event_type, object_id order by active_at_year asc, active_at_week asc)\n            as weeks_since_last_active \n    from weekly_rollup\n)\n\nselect\n    *,\n    case when weeks_since_last_active is null then true else false end as is_new,\n    case when weeks_since_last_active = 1 then true else false end as is_retained,\n    case when weeks_since_last_active > 1 then true else false end as is_returned\nfrom weekly_rollup_enhanced"}, "error": null, "status": null, "execution_time": 0.05123281478881836, "thread_id": "Thread-5", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.187812Z", "completed_at": "2020-11-10T01:45:31.235085Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.236120Z", "completed_at": "2020-11-10T01:45:31.236126Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{\n    config(materialized='table')\n}}\n\nwith yearly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_year,\n        sum(events) as events\n    from {{ ref('growth_accounting_activity') }}\n    group by 1,2,3,4\n),\n    \nyearly_rollup_enhanced as (\n    select\n        yearly_rollup.*,\n        yearly_rollup.active_at_year - lag(yearly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc)\n            as years_since_last_active \n    from yearly_rollup\n)\n\nselect\n    *,\n    case when years_since_last_active is null then true else false end as is_new,\n    case when years_since_last_active = 1 then true else false end as is_retained,\n    case when years_since_last_active > 1 then true else false end as is_returned\nfrom yearly_rollup_enhanced", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "accounting", "growth_accounting_by_year_draft"], "unique_id": "model.growth_accounting.growth_accounting_by_year_draft", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "accounting/growth_accounting_by_year_draft.sql", "original_file_path": "models/accounting/growth_accounting_by_year_draft.sql", "name": "growth_accounting_by_year_draft", "resource_type": "model", "alias": "growth_accounting_by_year_draft", "checksum": {"name": "sha256", "checksum": "4ce55aa18cda82c701d92abce9dae3afa9e426026a49a46bcc1a7303064764a3"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_activity"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/accounting/growth_accounting_by_year_draft.sql", "deferred": false, "compiled_sql": "\n\nwith yearly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4\n),\n    \nyearly_rollup_enhanced as (\n    select\n        yearly_rollup.*,\n        yearly_rollup.active_at_year - lag(yearly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc)\n            as years_since_last_active \n    from yearly_rollup\n)\n\nselect\n    *,\n    case when years_since_last_active is null then true else false end as is_new,\n    case when years_since_last_active = 1 then true else false end as is_retained,\n    case when years_since_last_active > 1 then true else false end as is_returned\nfrom yearly_rollup_enhanced", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith yearly_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4\n),\n    \nyearly_rollup_enhanced as (\n    select\n        yearly_rollup.*,\n        yearly_rollup.active_at_year - lag(yearly_rollup.active_at_year) over (partition by object_type, event_type, object_id order by active_at_year asc)\n            as years_since_last_active \n    from yearly_rollup\n)\n\nselect\n    *,\n    case when years_since_last_active is null then true else false end as is_new,\n    case when years_since_last_active = 1 then true else false end as is_retained,\n    case when years_since_last_active > 1 then true else false end as is_returned\nfrom yearly_rollup_enhanced"}, "error": null, "status": null, "execution_time": 0.05421638488769531, "thread_id": "Thread-3", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.188561Z", "completed_at": "2020-11-10T01:45:31.236982Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.237846Z", "completed_at": "2020-11-10T01:45:31.237853Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "/*\nI'm not really sure how to make the argument passing here more sensible without\nresearching how these macros actually work.\n*/\n\n{{\n    config(materialized='table')\n}}\n\n{% set end_date = dbt_utils.get_query_results_as_dict('select max(active_at)::varchar end_date from ' ~ ref('growth_accounting_activity')) %}\n{% set start_date = dbt_utils.get_query_results_as_dict('select min(active_at)::varchar start_date from ' ~ ref('growth_accounting_activity')) %}\n{% set end_date_str = \"'\" ~ end_date['end_date'][0] ~ \"'\" %}\n{% set start_date_str = \"'\" ~ start_date['start_date'][0] ~ \"'\" %}\n{% set start_date_arg = \"to_date(\" ~ start_date_str ~ \", 'yyyy-mm-dd')\" %}\n\n{{\n    dbt_utils.date_spine(\n        datepart='day',\n        start_date=start_date_arg,\n        end_date=end_date_str\n    )\n}}", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "core", "growth_accounting_dates"], "unique_id": "model.growth_accounting.growth_accounting_dates", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "core/growth_accounting_dates.sql", "original_file_path": "models/core/growth_accounting_dates.sql", "name": "growth_accounting_dates", "resource_type": "model", "alias": "growth_accounting_dates", "checksum": {"name": "sha256", "checksum": "099533c209080992fdf525a43e30cfba5c00e2a2180710300518fa789c8d75ea"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"], ["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": ["macro.dbt_utils.get_query_results_as_dict", "macro.dbt_utils.date_spine"], "nodes": ["model.growth_accounting.growth_accounting_activity", "model.growth_accounting.growth_accounting_activity"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/core/growth_accounting_dates.sql", "deferred": false, "compiled_sql": "/*\nI'm not really sure how to make the argument passing here more sensible without\nresearching how these macros actually work.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\ncall as follows:\n\ndate_spine(\n    \"day\",\n    \"to_date('01/01/2016', 'mm/dd/yyyy')\",\n    \"dateadd(week, 1, current_date)\"\n)\n\n*/\n\nwith rawdata as (\n\n    \n\n    \n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    \n    p0.generated_number * pow(2, 0)\n     + \n    \n    p1.generated_number * pow(2, 1)\n     + \n    \n    p2.generated_number * pow(2, 2)\n     + \n    \n    p3.generated_number * pow(2, 3)\n     + \n    \n    p4.generated_number * pow(2, 4)\n     + \n    \n    p5.generated_number * pow(2, 5)\n     + \n    \n    p6.generated_number * pow(2, 6)\n    \n    \n    + 1\n    as generated_number\n\n    from\n\n    \n    p as p0\n     cross join \n    \n    p as p1\n     cross join \n    \n    p as p2\n     cross join \n    \n    p as p3\n     cross join \n    \n    p as p4\n     cross join \n    \n    p as p5\n     cross join \n    \n    p as p6\n    \n    \n\n    )\n\n    select *\n    from unioned\n    where generated_number <= 117\n    order by generated_number\n\n\n\n),\n\nall_periods as (\n\n    select (\n        \n  \n\n    to_date('2020-08-30', 'yyyy-mm-dd') + ((interval '1 day') * (row_number() over (order by 1) - 1))\n\n\n\n    ) as date_day\n    from rawdata\n\n),\n\nfiltered as (\n\n    select *\n    from all_periods\n    where date_day <= '2020-12-25'\n\n)\n\nselect * from filtered\n\n", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "/*\nI'm not really sure how to make the argument passing here more sensible without\nresearching how these macros actually work.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\ncall as follows:\n\ndate_spine(\n    \"day\",\n    \"to_date('01/01/2016', 'mm/dd/yyyy')\",\n    \"dateadd(week, 1, current_date)\"\n)\n\n*/\n\nwith rawdata as (\n\n    \n\n    \n\n    with p as (\n        select 0 as generated_number union all select 1\n    ), unioned as (\n\n    select\n\n    \n    p0.generated_number * pow(2, 0)\n     + \n    \n    p1.generated_number * pow(2, 1)\n     + \n    \n    p2.generated_number * pow(2, 2)\n     + \n    \n    p3.generated_number * pow(2, 3)\n     + \n    \n    p4.generated_number * pow(2, 4)\n     + \n    \n    p5.generated_number * pow(2, 5)\n     + \n    \n    p6.generated_number * pow(2, 6)\n    \n    \n    + 1\n    as generated_number\n\n    from\n\n    \n    p as p0\n     cross join \n    \n    p as p1\n     cross join \n    \n    p as p2\n     cross join \n    \n    p as p3\n     cross join \n    \n    p as p4\n     cross join \n    \n    p as p5\n     cross join \n    \n    p as p6\n    \n    \n\n    )\n\n    select *\n    from unioned\n    where generated_number <= 117\n    order by generated_number\n\n\n\n),\n\nall_periods as (\n\n    select (\n        \n  \n\n    to_date('2020-08-30', 'yyyy-mm-dd') + ((interval '1 day') * (row_number() over (order by 1) - 1))\n\n\n\n    ) as date_day\n    from rawdata\n\n),\n\nfiltered as (\n\n    select *\n    from all_periods\n    where date_day <= '2020-12-25'\n\n)\n\nselect * from filtered\n\n"}, "error": null, "status": null, "execution_time": 0.1553058624267578, "thread_id": "Thread-1", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.187576Z", "completed_at": "2020-11-10T01:45:31.337356Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.337660Z", "completed_at": "2020-11-10T01:45:31.337668Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{ config(materialized='table') }}\n\nwith dates as (\n    select date_day::date as date\n    from {{ ref('growth_accounting_dates') }}\n),\n\ncohorts as (\n    select * from {{ ref('growth_accounting_cohorts') }}\n),\n\neligible_dates as (\n    select \n        dates.date,\n        cohorts.first_active_at,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.date >= cohorts.first_active_at\n),\n\neligible_dates_enhanced as (\n    select\n        eligible_dates.*,\n        case when daily_activity.active_at is null then false else true end as is_active,\n        -- Ideally we could just do `lag(active_at) ignore_nulls (partition by ...)` to get the last\n        -- active date\n        daily_activity.active_at\n    from eligible_dates\n    left join {{ ref('growth_accounting_activity') }} daily_activity\n    on eligible_dates.date = daily_activity.active_at\n        and eligible_dates.object_id = daily_activity.object_id\n        and eligible_dates.event_type = daily_activity.event_type\n        and eligible_dates.object_type = daily_activity.object_type\n),\n\n-- We only need to create this window manually on Postgres. Bigquery, Redshift, Snowflake\n-- all support `lag(active_at) ignore nulls` to select the first previous non-null value,\n-- but postgres does not.\neligible_dates_with_active_at_window as (\n    select \n        *,\n        count(active_at) over (partition by eligible_dates_enhanced.object_id,\n                                                eligible_dates_enhanced.event_type,\n                                                eligible_dates_enhanced.object_type\n                                order by eligible_dates_enhanced.date asc\n                                rows between unbounded preceding and current row) as active_at_window\n    from eligible_dates_enhanced\n),\n\nactivity_by_day as (\n    select\n        date,\n        object_id,\n        object_type,\n        event_type,\n        first_active_at,\n        first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as last_active_at,\n        is_active,\n        first_active_at = date as is_first_active,\n        date - first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as days_since_last_active\n    from eligible_dates_with_active_at_window ew\n),\n\nactivity_by_day_with_new_churned_flags as (\n    select\n        activity_by_day.*,\n        case when date - first_active_at < 1 then true else false end as is_1d_new,\n        case when date - first_active_at < 7 then true else false end as is_7d_new,\n        case when date - first_active_at < 30 then true else false end as is_30d_new,\n        case when date - first_active_at < 90 then true else false end as is_90d_new,\n        case when date - first_active_at < 365 then true else false end as is_365d_new,\n\n        -- Churned flags\n        case when days_since_last_active >= 1 then true else false end as is_1d_churned,\n        case when days_since_last_active >= 7 then true else false end as is_7d_churned,\n        case when days_since_last_active >= 30 then true else false end as is_30d_churned,\n        case when days_since_last_active >= 90 then true else false end as is_90d_churned,\n        case when days_since_last_active >= 365 then true else false end as is_365d_churned\n    from activity_by_day\n),\n\nactivity_by_day_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1d_churned) over cohort and is_active then true else false end as is_1d_returned,\n        case when lag(is_7d_churned) over cohort and is_active then true else false end as is_7d_returned,\n        case when lag(is_30d_churned) over cohort and is_active then true else false end as is_30d_returned,\n        case when lag(is_90d_churned) over cohort and is_active then true else false end as is_90d_returned,\n        case when lag(is_365d_churned) over cohort and is_active then true else false end as is_365d_returned\n    from activity_by_day_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by date asc)\n),\n\nactivity_by_day_with_all_flags as (\n    select\n        activity_by_day_with_returned_flags.*,\n        case when days_since_last_active < 1 and not is_1d_returned and not is_1d_new then true else false end as is_1d_retained,\n        case when days_since_last_active < 7 and not is_7d_returned and not is_7d_new then true else false end as is_7d_retained,\n        case when days_since_last_active < 30 and not is_30d_returned and not is_30d_new then true else false end as is_30d_retained,\n        case when days_since_last_active < 90 and not is_90d_returned and not is_90d_new then true else false end as is_90d_retained,\n        case when days_since_last_active < 365 and not is_365d_returned and not is_365d_new then true else false end as is_365d_retained\n    from activity_by_day_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1d_new then 'new'\n        when is_1d_churned then 'churned'\n        when is_1d_retained then 'retained'\n        when is_1d_returned then 'returned'\n        else null\n    end as status_1d,\n    case\n        when is_7d_new then 'new'\n        when is_7d_churned then 'churned'\n        when is_7d_retained then 'retained'\n        when is_7d_returned then 'returned'\n        else null\n    end as status_7d,\n    case\n        when is_30d_new then 'new'\n        when is_30d_churned then 'churned'\n        when is_30d_retained then 'retained'\n        when is_30d_returned then 'returned'\n        else null\n    end as status_30d,\n    case\n        when is_90d_new then 'new'\n        when is_90d_churned then 'churned'\n        when is_90d_retained then 'retained'\n        when is_90d_returned then 'returned'\n        else null\n    end as status_90d,\n    case\n        when is_365d_new then 'new'\n        when is_365d_churned then 'churned'\n        when is_365d_retained then 'retained'\n        when is_365d_returned then 'returned'\n        else null\n    end as status_365d    \nfrom activity_by_day_with_all_flags", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "accounting", "growth_accounting_by_day"], "unique_id": "model.growth_accounting.growth_accounting_by_day", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "accounting/growth_accounting_by_day.sql", "original_file_path": "models/accounting/growth_accounting_by_day.sql", "name": "growth_accounting_by_day", "resource_type": "model", "alias": "growth_accounting_by_day", "checksum": {"name": "sha256", "checksum": "76d7cc85bc44ecba71cd92984ab9eb5922d01f64e9b9d099d2c7c17fa024211f"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_dates"], ["growth_accounting_cohorts"], ["growth_accounting_activity"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_dates", "model.growth_accounting.growth_accounting_cohorts", "model.growth_accounting.growth_accounting_activity"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/accounting/growth_accounting_by_day.sql", "deferred": false, "compiled_sql": "\n\nwith dates as (\n    select date_day::date as date\n    from \"dev\".\"public\".\"growth_accounting_dates\"\n),\n\ncohorts as (\n    select * from \"dev\".\"public\".\"growth_accounting_cohorts\"\n),\n\neligible_dates as (\n    select \n        dates.date,\n        cohorts.first_active_at,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.date >= cohorts.first_active_at\n),\n\neligible_dates_enhanced as (\n    select\n        eligible_dates.*,\n        case when daily_activity.active_at is null then false else true end as is_active,\n        -- Ideally we could just do `lag(active_at) ignore_nulls (partition by ...)` to get the last\n        -- active date\n        daily_activity.active_at\n    from eligible_dates\n    left join \"dev\".\"public\".\"growth_accounting_activity\" daily_activity\n    on eligible_dates.date = daily_activity.active_at\n        and eligible_dates.object_id = daily_activity.object_id\n        and eligible_dates.event_type = daily_activity.event_type\n        and eligible_dates.object_type = daily_activity.object_type\n),\n\n-- We only need to create this window manually on Postgres. Bigquery, Redshift, Snowflake\n-- all support `lag(active_at) ignore nulls` to select the first previous non-null value,\n-- but postgres does not.\neligible_dates_with_active_at_window as (\n    select \n        *,\n        count(active_at) over (partition by eligible_dates_enhanced.object_id,\n                                                eligible_dates_enhanced.event_type,\n                                                eligible_dates_enhanced.object_type\n                                order by eligible_dates_enhanced.date asc\n                                rows between unbounded preceding and current row) as active_at_window\n    from eligible_dates_enhanced\n),\n\nactivity_by_day as (\n    select\n        date,\n        object_id,\n        object_type,\n        event_type,\n        first_active_at,\n        first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as last_active_at,\n        is_active,\n        first_active_at = date as is_first_active,\n        date - first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as days_since_last_active\n    from eligible_dates_with_active_at_window ew\n),\n\nactivity_by_day_with_new_churned_flags as (\n    select\n        activity_by_day.*,\n        case when date - first_active_at < 1 then true else false end as is_1d_new,\n        case when date - first_active_at < 7 then true else false end as is_7d_new,\n        case when date - first_active_at < 30 then true else false end as is_30d_new,\n        case when date - first_active_at < 90 then true else false end as is_90d_new,\n        case when date - first_active_at < 365 then true else false end as is_365d_new,\n\n        -- Churned flags\n        case when days_since_last_active >= 1 then true else false end as is_1d_churned,\n        case when days_since_last_active >= 7 then true else false end as is_7d_churned,\n        case when days_since_last_active >= 30 then true else false end as is_30d_churned,\n        case when days_since_last_active >= 90 then true else false end as is_90d_churned,\n        case when days_since_last_active >= 365 then true else false end as is_365d_churned\n    from activity_by_day\n),\n\nactivity_by_day_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1d_churned) over cohort and is_active then true else false end as is_1d_returned,\n        case when lag(is_7d_churned) over cohort and is_active then true else false end as is_7d_returned,\n        case when lag(is_30d_churned) over cohort and is_active then true else false end as is_30d_returned,\n        case when lag(is_90d_churned) over cohort and is_active then true else false end as is_90d_returned,\n        case when lag(is_365d_churned) over cohort and is_active then true else false end as is_365d_returned\n    from activity_by_day_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by date asc)\n),\n\nactivity_by_day_with_all_flags as (\n    select\n        activity_by_day_with_returned_flags.*,\n        case when days_since_last_active < 1 and not is_1d_returned and not is_1d_new then true else false end as is_1d_retained,\n        case when days_since_last_active < 7 and not is_7d_returned and not is_7d_new then true else false end as is_7d_retained,\n        case when days_since_last_active < 30 and not is_30d_returned and not is_30d_new then true else false end as is_30d_retained,\n        case when days_since_last_active < 90 and not is_90d_returned and not is_90d_new then true else false end as is_90d_retained,\n        case when days_since_last_active < 365 and not is_365d_returned and not is_365d_new then true else false end as is_365d_retained\n    from activity_by_day_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1d_new then 'new'\n        when is_1d_churned then 'churned'\n        when is_1d_retained then 'retained'\n        when is_1d_returned then 'returned'\n        else null\n    end as status_1d,\n    case\n        when is_7d_new then 'new'\n        when is_7d_churned then 'churned'\n        when is_7d_retained then 'retained'\n        when is_7d_returned then 'returned'\n        else null\n    end as status_7d,\n    case\n        when is_30d_new then 'new'\n        when is_30d_churned then 'churned'\n        when is_30d_retained then 'retained'\n        when is_30d_returned then 'returned'\n        else null\n    end as status_30d,\n    case\n        when is_90d_new then 'new'\n        when is_90d_churned then 'churned'\n        when is_90d_retained then 'retained'\n        when is_90d_returned then 'returned'\n        else null\n    end as status_90d,\n    case\n        when is_365d_new then 'new'\n        when is_365d_churned then 'churned'\n        when is_365d_retained then 'retained'\n        when is_365d_returned then 'returned'\n        else null\n    end as status_365d    \nfrom activity_by_day_with_all_flags", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith dates as (\n    select date_day::date as date\n    from \"dev\".\"public\".\"growth_accounting_dates\"\n),\n\ncohorts as (\n    select * from \"dev\".\"public\".\"growth_accounting_cohorts\"\n),\n\neligible_dates as (\n    select \n        dates.date,\n        cohorts.first_active_at,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.date >= cohorts.first_active_at\n),\n\neligible_dates_enhanced as (\n    select\n        eligible_dates.*,\n        case when daily_activity.active_at is null then false else true end as is_active,\n        -- Ideally we could just do `lag(active_at) ignore_nulls (partition by ...)` to get the last\n        -- active date\n        daily_activity.active_at\n    from eligible_dates\n    left join \"dev\".\"public\".\"growth_accounting_activity\" daily_activity\n    on eligible_dates.date = daily_activity.active_at\n        and eligible_dates.object_id = daily_activity.object_id\n        and eligible_dates.event_type = daily_activity.event_type\n        and eligible_dates.object_type = daily_activity.object_type\n),\n\n-- We only need to create this window manually on Postgres. Bigquery, Redshift, Snowflake\n-- all support `lag(active_at) ignore nulls` to select the first previous non-null value,\n-- but postgres does not.\neligible_dates_with_active_at_window as (\n    select \n        *,\n        count(active_at) over (partition by eligible_dates_enhanced.object_id,\n                                                eligible_dates_enhanced.event_type,\n                                                eligible_dates_enhanced.object_type\n                                order by eligible_dates_enhanced.date asc\n                                rows between unbounded preceding and current row) as active_at_window\n    from eligible_dates_enhanced\n),\n\nactivity_by_day as (\n    select\n        date,\n        object_id,\n        object_type,\n        event_type,\n        first_active_at,\n        first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as last_active_at,\n        is_active,\n        first_active_at = date as is_first_active,\n        date - first_value(active_at) over (partition by ew.object_id,\n                                                ew.event_type,\n                                                ew.object_type,\n                                                ew.active_at_window) as days_since_last_active\n    from eligible_dates_with_active_at_window ew\n),\n\nactivity_by_day_with_new_churned_flags as (\n    select\n        activity_by_day.*,\n        case when date - first_active_at < 1 then true else false end as is_1d_new,\n        case when date - first_active_at < 7 then true else false end as is_7d_new,\n        case when date - first_active_at < 30 then true else false end as is_30d_new,\n        case when date - first_active_at < 90 then true else false end as is_90d_new,\n        case when date - first_active_at < 365 then true else false end as is_365d_new,\n\n        -- Churned flags\n        case when days_since_last_active >= 1 then true else false end as is_1d_churned,\n        case when days_since_last_active >= 7 then true else false end as is_7d_churned,\n        case when days_since_last_active >= 30 then true else false end as is_30d_churned,\n        case when days_since_last_active >= 90 then true else false end as is_90d_churned,\n        case when days_since_last_active >= 365 then true else false end as is_365d_churned\n    from activity_by_day\n),\n\nactivity_by_day_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1d_churned) over cohort and is_active then true else false end as is_1d_returned,\n        case when lag(is_7d_churned) over cohort and is_active then true else false end as is_7d_returned,\n        case when lag(is_30d_churned) over cohort and is_active then true else false end as is_30d_returned,\n        case when lag(is_90d_churned) over cohort and is_active then true else false end as is_90d_returned,\n        case when lag(is_365d_churned) over cohort and is_active then true else false end as is_365d_returned\n    from activity_by_day_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by date asc)\n),\n\nactivity_by_day_with_all_flags as (\n    select\n        activity_by_day_with_returned_flags.*,\n        case when days_since_last_active < 1 and not is_1d_returned and not is_1d_new then true else false end as is_1d_retained,\n        case when days_since_last_active < 7 and not is_7d_returned and not is_7d_new then true else false end as is_7d_retained,\n        case when days_since_last_active < 30 and not is_30d_returned and not is_30d_new then true else false end as is_30d_retained,\n        case when days_since_last_active < 90 and not is_90d_returned and not is_90d_new then true else false end as is_90d_retained,\n        case when days_since_last_active < 365 and not is_365d_returned and not is_365d_new then true else false end as is_365d_retained\n    from activity_by_day_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1d_new then 'new'\n        when is_1d_churned then 'churned'\n        when is_1d_retained then 'retained'\n        when is_1d_returned then 'returned'\n        else null\n    end as status_1d,\n    case\n        when is_7d_new then 'new'\n        when is_7d_churned then 'churned'\n        when is_7d_retained then 'retained'\n        when is_7d_returned then 'returned'\n        else null\n    end as status_7d,\n    case\n        when is_30d_new then 'new'\n        when is_30d_churned then 'churned'\n        when is_30d_retained then 'retained'\n        when is_30d_returned then 'returned'\n        else null\n    end as status_30d,\n    case\n        when is_90d_new then 'new'\n        when is_90d_churned then 'churned'\n        when is_90d_retained then 'retained'\n        when is_90d_returned then 'returned'\n        else null\n    end as status_90d,\n    case\n        when is_365d_new then 'new'\n        when is_365d_churned then 'churned'\n        when is_365d_retained then 'retained'\n        when is_365d_returned then 'returned'\n        else null\n    end as status_365d    \nfrom activity_by_day_with_all_flags"}, "error": null, "status": null, "execution_time": 0.024869203567504883, "thread_id": "Thread-4", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.342741Z", "completed_at": "2020-11-10T01:45:31.366035Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.366343Z", "completed_at": "2020-11-10T01:45:31.366351Z"}], "fail": null, "warn": null, "skip": false}, {"node": {"raw_sql": "{{\n    config(materialized='table')\n}}\n\nwith monthly_activity_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_month,\n        active_at_year,\n        sum(events) as events\n    from {{ ref('growth_accounting_activity') }}\n    group by 1,2,3,4,5\n),\n\ndates as (\n    select distinct\n        extract(year from date_day::date)::integer as year,\n        extract(month from date_day::date)::integer as month\n    from {{ ref('growth_accounting_dates') }}\n),\n\ncohorts as (\n    select * from {{ ref('growth_accounting_cohorts') }}\n),\n\neligible_dates as (\n    select \n        dates.year,\n        dates.month,\n        cohorts.first_active_at_year,\n        cohorts.first_active_at_month,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.year >= cohorts.first_active_at_year \n        and dates.month >= cohorts.first_active_at_month\n),\n\neligible_dates_with_active_flag as (\n    select\n        eligible_dates.*,\n        case when monthly_activity_rollup.active_at_month is null then false else true end as is_active\n    from eligible_dates\n    left join monthly_activity_rollup\n    on eligible_dates.year = monthly_activity_rollup.active_at_year\n        and eligible_dates.month = monthly_activity_rollup.active_at_month\n        and eligible_dates.object_id = monthly_activity_rollup.object_id\n        and eligible_dates.event_type = monthly_activity_rollup.event_type\n        and eligible_dates.object_type = monthly_activity_rollup.object_type\n),\n\neligible_dates_with_active_groups as (\n    select\n        *,\n        sum(is_active::int) over (partition by object_type, object_id, event_type order by \"year\" asc, \"month\" asc rows between unbounded preceding and current row) last_active_window\n    from eligible_dates_with_active_flag\n),\n\neligible_dates_with_last_active_dates as (\n    select\n        *,\n        first_value(year) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_year,\n        first_value(month) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_month\n    from eligible_dates_with_active_groups\n),\n\neligible_dates_with_months_since_last_active as (\n    select\n        *,\n        12 * (year - last_active_year) + (month - last_active_month) as months_since_last_active,\n        12 * (year - first_active_at_year) + (month - first_active_at_month) as months_since_first_active\n    from eligible_dates_with_last_active_dates\n),\n\nactivity_by_month_with_new_churned_flags as (\n    select\n        eligible_dates_with_months_since_last_active.*,\n        case when months_since_first_active < 1 then true else false end as is_1m_new,\n        case when months_since_first_active < 3 then true else false end as is_3m_new,\n        case when months_since_first_active < 6 then true else false end as is_6m_new,\n        case when months_since_first_active < 12 then true else false end as is_12m_new,\n\n        -- Churned flags\n        case when months_since_last_active >= 1 then true else false end as is_1m_churned,\n        case when months_since_last_active >= 3 then true else false end as is_3m_churned,\n        case when months_since_last_active >= 6 then true else false end as is_6m_churned,\n        case when months_since_last_active >= 12 then true else false end as is_12m_churned\n    from eligible_dates_with_months_since_last_active\n),\n\nactivity_by_month_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1m_churned) over cohort and is_active then true else false end as is_1m_returned,\n        case when lag(is_3m_churned) over cohort and is_active then true else false end as is_3m_returned,\n        case when lag(is_6m_churned) over cohort and is_active then true else false end as is_6m_returned,\n        case when lag(is_12m_churned) over cohort and is_active then true else false end as is_12m_returned\n    from activity_by_month_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by year asc, month asc)\n),\n\nactivity_by_month_with_all_flags as (\n    select\n        *,\n        case when months_since_last_active < 1 and not is_1m_returned and not is_1m_new then true else false end as is_1m_retained,\n        case when months_since_last_active < 3 and not is_3m_returned and not is_3m_new then true else false end as is_3m_retained,\n        case when months_since_last_active < 6 and not is_6m_returned and not is_6m_new then true else false end as is_6m_retained,\n        case when months_since_last_active < 12 and not is_12m_returned and not is_12m_new then true else false end as is_12m_retained\n    from activity_by_month_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1m_new then 'new'\n        when is_1m_churned then 'churned'\n        when is_1m_retained then 'retained'\n        when is_1m_returned then 'returned'\n        else null\n    end as status_1m,\n    case\n        when is_3m_new then 'new'\n        when is_3m_churned then 'churned'\n        when is_3m_retained then 'retained'\n        when is_3m_returned then 'returned'\n        else null\n    end as status_3m,\n    case\n        when is_6m_new then 'new'\n        when is_6m_churned then 'churned'\n        when is_6m_retained then 'retained'\n        when is_6m_returned then 'returned'\n        else null\n    end as status_6m,\n    case\n        when is_12m_new then 'new'\n        when is_12m_churned then 'churned'\n        when is_12m_retained then 'retained'\n        when is_12m_returned then 'returned'\n        else null\n    end as status_12m   \nfrom activity_by_month_with_all_flags", "compiled": true, "database": "dev", "schema": "public", "fqn": ["growth_accounting", "accounting", "growth_accounting_by_month"], "unique_id": "model.growth_accounting.growth_accounting_by_month", "package_name": "growth_accounting", "root_path": "/home/runner/work/dbt-growth-accounting/dbt-growth-accounting", "path": "accounting/growth_accounting_by_month.sql", "original_file_path": "models/accounting/growth_accounting_by_month.sql", "name": "growth_accounting_by_month", "resource_type": "model", "alias": "growth_accounting_by_month", "checksum": {"name": "sha256", "checksum": "e036bd75998033bd1c3621f1dc3d889edab1ef9b93ec2b9a89d1c2a17fab0802"}, "config": {"enabled": true, "materialized": "table", "persist_docs": {}, "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}, "alias": null, "schema": null, "database": null, "tags": [], "full_refresh": null, "growth_accounting": null}, "tags": [], "refs": [["growth_accounting_activity"], ["growth_accounting_dates"], ["growth_accounting_cohorts"]], "sources": [], "depends_on": {"macros": [], "nodes": ["model.growth_accounting.growth_accounting_activity", "model.growth_accounting.growth_accounting_dates", "model.growth_accounting.growth_accounting_cohorts"]}, "description": "", "columns": {}, "meta": {}, "docs": {"show": true}, "patch_path": null, "build_path": "target/compiled/growth_accounting/models/accounting/growth_accounting_by_month.sql", "deferred": false, "compiled_sql": "\n\nwith monthly_activity_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_month,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n\ndates as (\n    select distinct\n        extract(year from date_day::date)::integer as year,\n        extract(month from date_day::date)::integer as month\n    from \"dev\".\"public\".\"growth_accounting_dates\"\n),\n\ncohorts as (\n    select * from \"dev\".\"public\".\"growth_accounting_cohorts\"\n),\n\neligible_dates as (\n    select \n        dates.year,\n        dates.month,\n        cohorts.first_active_at_year,\n        cohorts.first_active_at_month,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.year >= cohorts.first_active_at_year \n        and dates.month >= cohorts.first_active_at_month\n),\n\neligible_dates_with_active_flag as (\n    select\n        eligible_dates.*,\n        case when monthly_activity_rollup.active_at_month is null then false else true end as is_active\n    from eligible_dates\n    left join monthly_activity_rollup\n    on eligible_dates.year = monthly_activity_rollup.active_at_year\n        and eligible_dates.month = monthly_activity_rollup.active_at_month\n        and eligible_dates.object_id = monthly_activity_rollup.object_id\n        and eligible_dates.event_type = monthly_activity_rollup.event_type\n        and eligible_dates.object_type = monthly_activity_rollup.object_type\n),\n\neligible_dates_with_active_groups as (\n    select\n        *,\n        sum(is_active::int) over (partition by object_type, object_id, event_type order by \"year\" asc, \"month\" asc rows between unbounded preceding and current row) last_active_window\n    from eligible_dates_with_active_flag\n),\n\neligible_dates_with_last_active_dates as (\n    select\n        *,\n        first_value(year) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_year,\n        first_value(month) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_month\n    from eligible_dates_with_active_groups\n),\n\neligible_dates_with_months_since_last_active as (\n    select\n        *,\n        12 * (year - last_active_year) + (month - last_active_month) as months_since_last_active,\n        12 * (year - first_active_at_year) + (month - first_active_at_month) as months_since_first_active\n    from eligible_dates_with_last_active_dates\n),\n\nactivity_by_month_with_new_churned_flags as (\n    select\n        eligible_dates_with_months_since_last_active.*,\n        case when months_since_first_active < 1 then true else false end as is_1m_new,\n        case when months_since_first_active < 3 then true else false end as is_3m_new,\n        case when months_since_first_active < 6 then true else false end as is_6m_new,\n        case when months_since_first_active < 12 then true else false end as is_12m_new,\n\n        -- Churned flags\n        case when months_since_last_active >= 1 then true else false end as is_1m_churned,\n        case when months_since_last_active >= 3 then true else false end as is_3m_churned,\n        case when months_since_last_active >= 6 then true else false end as is_6m_churned,\n        case when months_since_last_active >= 12 then true else false end as is_12m_churned\n    from eligible_dates_with_months_since_last_active\n),\n\nactivity_by_month_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1m_churned) over cohort and is_active then true else false end as is_1m_returned,\n        case when lag(is_3m_churned) over cohort and is_active then true else false end as is_3m_returned,\n        case when lag(is_6m_churned) over cohort and is_active then true else false end as is_6m_returned,\n        case when lag(is_12m_churned) over cohort and is_active then true else false end as is_12m_returned\n    from activity_by_month_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by year asc, month asc)\n),\n\nactivity_by_month_with_all_flags as (\n    select\n        *,\n        case when months_since_last_active < 1 and not is_1m_returned and not is_1m_new then true else false end as is_1m_retained,\n        case when months_since_last_active < 3 and not is_3m_returned and not is_3m_new then true else false end as is_3m_retained,\n        case when months_since_last_active < 6 and not is_6m_returned and not is_6m_new then true else false end as is_6m_retained,\n        case when months_since_last_active < 12 and not is_12m_returned and not is_12m_new then true else false end as is_12m_retained\n    from activity_by_month_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1m_new then 'new'\n        when is_1m_churned then 'churned'\n        when is_1m_retained then 'retained'\n        when is_1m_returned then 'returned'\n        else null\n    end as status_1m,\n    case\n        when is_3m_new then 'new'\n        when is_3m_churned then 'churned'\n        when is_3m_retained then 'retained'\n        when is_3m_returned then 'returned'\n        else null\n    end as status_3m,\n    case\n        when is_6m_new then 'new'\n        when is_6m_churned then 'churned'\n        when is_6m_retained then 'retained'\n        when is_6m_returned then 'returned'\n        else null\n    end as status_6m,\n    case\n        when is_12m_new then 'new'\n        when is_12m_churned then 'churned'\n        when is_12m_retained then 'retained'\n        when is_12m_returned then 'returned'\n        else null\n    end as status_12m   \nfrom activity_by_month_with_all_flags", "extra_ctes_injected": true, "extra_ctes": [], "injected_sql": "\n\nwith monthly_activity_rollup as (\n    select \n        object_type,\n        event_type,\n        object_id,\n        active_at_month,\n        active_at_year,\n        sum(events) as events\n    from \"dev\".\"public\".\"growth_accounting_activity\"\n    group by 1,2,3,4,5\n),\n\ndates as (\n    select distinct\n        extract(year from date_day::date)::integer as year,\n        extract(month from date_day::date)::integer as month\n    from \"dev\".\"public\".\"growth_accounting_dates\"\n),\n\ncohorts as (\n    select * from \"dev\".\"public\".\"growth_accounting_cohorts\"\n),\n\neligible_dates as (\n    select \n        dates.year,\n        dates.month,\n        cohorts.first_active_at_year,\n        cohorts.first_active_at_month,\n        cohorts.object_id,\n        cohorts.object_type,\n        cohorts.event_type\n    from dates \n    left join cohorts on dates.year >= cohorts.first_active_at_year \n        and dates.month >= cohorts.first_active_at_month\n),\n\neligible_dates_with_active_flag as (\n    select\n        eligible_dates.*,\n        case when monthly_activity_rollup.active_at_month is null then false else true end as is_active\n    from eligible_dates\n    left join monthly_activity_rollup\n    on eligible_dates.year = monthly_activity_rollup.active_at_year\n        and eligible_dates.month = monthly_activity_rollup.active_at_month\n        and eligible_dates.object_id = monthly_activity_rollup.object_id\n        and eligible_dates.event_type = monthly_activity_rollup.event_type\n        and eligible_dates.object_type = monthly_activity_rollup.object_type\n),\n\neligible_dates_with_active_groups as (\n    select\n        *,\n        sum(is_active::int) over (partition by object_type, object_id, event_type order by \"year\" asc, \"month\" asc rows between unbounded preceding and current row) last_active_window\n    from eligible_dates_with_active_flag\n),\n\neligible_dates_with_last_active_dates as (\n    select\n        *,\n        first_value(year) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_year,\n        first_value(month) over (partition by last_active_window, object_type, object_id, event_type order by \"year\" asc, \"month\") as last_active_month\n    from eligible_dates_with_active_groups\n),\n\neligible_dates_with_months_since_last_active as (\n    select\n        *,\n        12 * (year - last_active_year) + (month - last_active_month) as months_since_last_active,\n        12 * (year - first_active_at_year) + (month - first_active_at_month) as months_since_first_active\n    from eligible_dates_with_last_active_dates\n),\n\nactivity_by_month_with_new_churned_flags as (\n    select\n        eligible_dates_with_months_since_last_active.*,\n        case when months_since_first_active < 1 then true else false end as is_1m_new,\n        case when months_since_first_active < 3 then true else false end as is_3m_new,\n        case when months_since_first_active < 6 then true else false end as is_6m_new,\n        case when months_since_first_active < 12 then true else false end as is_12m_new,\n\n        -- Churned flags\n        case when months_since_last_active >= 1 then true else false end as is_1m_churned,\n        case when months_since_last_active >= 3 then true else false end as is_3m_churned,\n        case when months_since_last_active >= 6 then true else false end as is_6m_churned,\n        case when months_since_last_active >= 12 then true else false end as is_12m_churned\n    from eligible_dates_with_months_since_last_active\n),\n\nactivity_by_month_with_returned_flags as (\n    select\n        *,\n        case when lag(is_1m_churned) over cohort and is_active then true else false end as is_1m_returned,\n        case when lag(is_3m_churned) over cohort and is_active then true else false end as is_3m_returned,\n        case when lag(is_6m_churned) over cohort and is_active then true else false end as is_6m_returned,\n        case when lag(is_12m_churned) over cohort and is_active then true else false end as is_12m_returned\n    from activity_by_month_with_new_churned_flags\n    window cohort as (partition by object_id, object_type, event_type order by year asc, month asc)\n),\n\nactivity_by_month_with_all_flags as (\n    select\n        *,\n        case when months_since_last_active < 1 and not is_1m_returned and not is_1m_new then true else false end as is_1m_retained,\n        case when months_since_last_active < 3 and not is_3m_returned and not is_3m_new then true else false end as is_3m_retained,\n        case when months_since_last_active < 6 and not is_6m_returned and not is_6m_new then true else false end as is_6m_retained,\n        case when months_since_last_active < 12 and not is_12m_returned and not is_12m_new then true else false end as is_12m_retained\n    from activity_by_month_with_returned_flags\n)\n\nselect\n    *,\n    case\n        when is_1m_new then 'new'\n        when is_1m_churned then 'churned'\n        when is_1m_retained then 'retained'\n        when is_1m_returned then 'returned'\n        else null\n    end as status_1m,\n    case\n        when is_3m_new then 'new'\n        when is_3m_churned then 'churned'\n        when is_3m_retained then 'retained'\n        when is_3m_returned then 'returned'\n        else null\n    end as status_3m,\n    case\n        when is_6m_new then 'new'\n        when is_6m_churned then 'churned'\n        when is_6m_retained then 'retained'\n        when is_6m_returned then 'returned'\n        else null\n    end as status_6m,\n    case\n        when is_12m_new then 'new'\n        when is_12m_churned then 'churned'\n        when is_12m_retained then 'retained'\n        when is_12m_returned then 'returned'\n        else null\n    end as status_12m   \nfrom activity_by_month_with_all_flags"}, "error": null, "status": null, "execution_time": 0.02552628517150879, "thread_id": "Thread-6", "timing": [{"name": "compile", "started_at": "2020-11-10T01:45:31.342910Z", "completed_at": "2020-11-10T01:45:31.367119Z"}, {"name": "execute", "started_at": "2020-11-10T01:45:31.367404Z", "completed_at": "2020-11-10T01:45:31.367411Z"}], "fail": null, "warn": null, "skip": false}], "generated_at": "2020-11-10T01:45:31.369615Z", "elapsed_time": 0.35947442054748535}